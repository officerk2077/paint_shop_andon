const SIMULATION_TICK_RATE = 1000; // ms - T·∫ßn su·∫•t ch·∫°y v√≤ng l·∫∑p m√¥ ph·ªèng

let io; // Instance Socket.IO
let pool; // Instance MySQL connection pool
let stationsData = {}; // Cache d·ªØ li·ªáu c√°c tr·∫°m { id: { name, capacity, takt_time, ... } }
let activeVehicles = []; // Danh s√°ch xe ƒëang ho·∫°t ƒë·ªông trong b·ªô nh·ªõ [{ ..., slotEntryTime, stationEntryTime }]
let errorTypesData = []; // Cache danh s√°ch lo·∫°i l·ªói [{ id, name }]
let simulationIntervalId = null; // ID c·ªßa setTimeout cho v√≤ng l·∫∑p tick

// IDs tr·∫°m ƒë·∫∑c bi·ªát
const OVEN_STATION_IDS = [4, 14];
const inspection_station_id = 10;
const repair_station_id = 23;
const post_repair_destination_id = 12; // Prepare (ƒê√≠ch ƒë·∫øn sau khi s·ª≠a l·ªói Primer/Recoat)
const TOPCOAT_INSPECTION_ID = 17;
const OFFLINE_REPAIR_ID = 25;
const FINISHING_ID = 18;
const WAIT_RECOAT_ID = 24;

// T·ª∑ l·ªá l·ªói ng·∫´u nhi√™n
const inspection_failure_rate = 0.2; // T·ª∑ l·ªá l·ªói t·∫°i P/M Inspection (ch·ªâ 1 l·∫ßn trong v√≤ng 0 ho·∫∑c 1)
const TOPCOAT_FAILURE_RATE = 0.3;    // T·ª∑ l·ªá l·ªói t·∫°i Topcoat Inspection
const OFFLINE_REPAIR_SUCCESS_RATE = 0.9; // T·ª∑ l·ªá s·ª≠a th√†nh c√¥ng t·∫°i Offline Repair

// Truy v·∫•n SQL l·∫•y th√¥ng tin xe bao g·ªìm c·∫£ t√™n l·ªói hi·ªán t·∫°i (n·∫øu c√≥)
const SELECT_VEHICLES_QUERY = `
    SELECT
        v.*,
        cb.model_name,
        cb.target_color,
        cb.color_hex,
        et.name AS current_error_name
    FROM vehicles v
    JOIN car_bodies cb ON v.body_id = cb.body_id
    LEFT JOIN error_types et ON v.current_error_type_id = et.id
`;

// --- H√ÄM GHI LOG ---
async function logEvent(type, message) {
    let insertedId = null;
    try {
        const query = 'INSERT INTO logs (type, message) VALUES (?, ?)';
        const [result] = await pool.execute(query, [type, message]);
        insertedId = result.insertId;
    } catch (error) { console.error(`‚ùå DB Log Error: ${error.message}`); }
    if (insertedId && io) {
        const newLogEntry = { id: insertedId, timestamp: new Date().toISOString(), type: type, message: message };
        io.emit('new-log', newLogEntry); // Ph√°t s·ª± ki·ªán log m·ªõi cho client
    }
}

/**
 * H√†m L√ïI: V√≤ng l·∫∑p ki·ªÉm tra v√† di chuy·ªÉn xe, ch·∫°y m·ªói SIMULATION_TICK_RATE ms
 */
async function simulationTick() {
    const now = Date.now();
    const dbUpdates = []; // Gom c√°c l·ªánh DB update ƒë·ªÉ ch·∫°y transaction
    let stateChanged = false; // C·ªù b√°o hi·ªáu c√≥ thay ƒë·ªïi tr·∫°ng th√°i c·∫ßn broadcast
    // console.log(`--- Tick: ${new Date().toLocaleTimeString()} ---`);

    // --- X·ª¨ L√ù BUFFER ·∫¢O (ID 0) ---
    // ƒê∆∞a xe t·ª´ buffer (h√†ng ch·ªù) v√†o tr·∫°m Loading (ID 1) n·∫øu c√≤n ch·ªó
    const vehiclesInBuffer = activeVehicles.filter(v => v.current_station_id === 0).sort((a, b) => new Date(a.created_at) - new Date(b.created_at)); // FIFO
    if (vehiclesInBuffer.length > 0) {
        const loadingStation = stationsData[1]; // Tr·∫°m Loading
        if (loadingStation && loadingStation.capacity > 0) {
            let occupiedSlotsSet = new Set(activeVehicles.filter(v => v.current_station_id === 1).map(v => v.slot_position));
            let bufferIndex = 0;
            // C·ªë g·∫Øng l·∫•p ƒë·∫ßy t·∫•t c·∫£ slot tr·ªëng trong c√πng 1 tick
            while (bufferIndex < vehiclesInBuffer.length && occupiedSlotsSet.size < loadingStation.capacity) {
                let targetSlotPosition = -1;
                // T√¨m slot tr·ªëng t·ª´ cu·ªëi l√™n (∆∞u ti√™n slot index cao)
                for (let i = loadingStation.capacity - 1; i >= 0; i--) { if (!occupiedSlotsSet.has(i)) { targetSlotPosition = i; break; } }
                if (targetSlotPosition === -1) break; // H·∫øt slot tr·ªëng

                const vehicleToLoad = vehiclesInBuffer[bufferIndex];

                // Chu·∫©n b·ªã c·∫≠p nh·∫≠t DB
                const updateQuery = 'UPDATE vehicles SET current_station_id = ?, slot_position = ?, status = ? WHERE body_id = ?';
                dbUpdates.push({ query: updateQuery, params: [1, targetSlotPosition, 'ok', vehicleToLoad.body_id] });

                // C·∫≠p nh·∫≠t b·ªô nh·ªõ ngay
                const vehicleInActiveList = activeVehicles.find(v => v.id === vehicleToLoad.id);
                if (vehicleInActiveList) {
                    vehicleInActiveList.current_station_id = 1; vehicleInActiveList.slot_position = targetSlotPosition;
                    vehicleInActiveList.slotEntryTime = now; vehicleInActiveList.stationEntryTime = now;
                    vehicleInActiveList.status = 'ok'; // Xe m·ªõi v√†o chuy·ªÅn lu√¥n 'ok'
                } else { console.error(`L·ªói logic buffer: Kh√¥ng t√¨m th·∫•y ${vehicleToLoad.body_id}`); bufferIndex++; continue; }

                stateChanged = true;
                await logEvent('info', `Xe ${vehicleToLoad.body_id} v√†o Loading slot ${targetSlotPosition}.`);
                occupiedSlotsSet.add(targetSlotPosition); // ƒê√°nh d·∫•u slot ƒë√£ chi·∫øm cho l·∫ßn l·∫∑p while ti·∫øp theo
                bufferIndex++; // X√©t xe ti·∫øp theo trong buffer
            }
        }
    }

    // --- X·ª¨ L√ù C√ÅC TR·∫†M TH·ª∞C T·∫æ (ID > 0) ---
    const activeStationIds = [...new Set(activeVehicles.map(v => v.current_station_id))].filter(id => id !== 0);
    for (const stationId of activeStationIds) {
        const currentStation = stationsData[stationId];
        if (!currentStation) continue;
        // X·ª≠ l√Ω xe t·ª´ slot cu·ªëi l√™n tr∆∞·ªõc (h·ªá th·ªëng k√©o)
        const vehiclesAtStation = activeVehicles.filter(v => v.current_station_id === stationId).sort((a, b) => b.slot_position - a.slot_position);

        for (const vehicle of vehiclesAtStation) {
            if (['error_stoppage', 'error_logic'].includes(vehicle.status)) continue; // B·ªè qua xe l·ªói h·ªá th·ªëng
            // Kh·ªüi t·∫°o th·ªùi gian v√†o n·∫øu ch∆∞a c√≥
            if (!vehicle.slotEntryTime) { vehicle.slotEntryTime = now; stateChanged = true; }
            if (!vehicle.stationEntryTime) { vehicle.stationEntryTime = vehicle.slotEntryTime; stateChanged = true; }
            // Ki·ªÉm tra d·ªØ li·ªáu capacity h·ª£p l·ªá
            if (!currentStation.capacity || currentStation.capacity <= 0) { await logEvent('error', `L·ªói capacity tr·∫°m ${currentStation.name}.`); vehicle.status = 'error_logic'; stateChanged = true; continue; }

            // --- T√çNH TO√ÅN TH·ªúI GIAN CH·ªú ---
            let requiredTime = 0, timeElapsed = 0;
            const isOven = OVEN_STATION_IDS.includes(currentStation.id);
            const isLastSlot = vehicle.slot_position === currentStation.capacity - 1;
            const stationTaktTime = currentStation.takt_time || 15000;
            const capacity = currentStation.capacity > 0 ? currentStation.capacity : 1;
            const isSpecialTimeStation = currentStation.id === repair_station_id || currentStation.id === OFFLINE_REPAIR_ID || currentStation.id === WAIT_RECOAT_ID;
            // L√≤ s·∫•y v√† tr·∫°m s·ª≠a ch·ªØa (·ªü slot cu·ªëi) d√πng t·ªïng th·ªùi gian v√†o tr·∫°m
            if ((isOven && isLastSlot) || (isSpecialTimeStation && isLastSlot)) {
                 requiredTime = stationTaktTime; timeElapsed = now - (vehicle.stationEntryTime || now);
             } else { // C√°c tr·∫°m/slot kh√°c d√πng th·ªùi gian v√†o slot
                 requiredTime = stationTaktTime / capacity; timeElapsed = now - (vehicle.slotEntryTime || now);
             }

            // --- QUY·∫æT ƒê·ªäNH C√ì TH·ª¨ DI CHUY·ªÇN KH√îNG ---
            let attemptMove = false;
            if (timeElapsed >= requiredTime) { // ƒê·ªß th·ªùi gian
                attemptMove = true;
                if (vehicle.status === 'blocked') { // N·∫øu ƒëang block v√† ƒë·ªß th·ªùi gian, th·ª≠ reset th√†nh 'ok' (n·∫øu kh√¥ng ph·∫£i rework)
                    if (vehicle.status !== 'rework' && vehicle.status !== 'rework_offline') { vehicle.status = 'ok'; }
                    stateChanged = true;
                }
            } else if (vehicle.status === 'blocked') { attemptMove = true; } // ƒêang block -> V·∫´n th·ª≠ di chuy·ªÉn

            // DEBUG 22: Log tr·∫°ng th√°i tr∆∞·ªõc khi quy·∫øt ƒë·ªãnh di chuy·ªÉn
            if (vehicle.current_station_id === 22) {
                 console.log(`[DEBUG 22 PreCheck] Xe ${vehicle.body_id} | Slot: ${vehicle.slot_position} | Status: ${vehicle.status} | Time OK: ${timeElapsed >= requiredTime} | AttemptMove: ${attemptMove}`);
            }

            if (!attemptMove) continue; // Ch∆∞a ƒë·ªß th·ªùi gian v√† kh√¥ng b·ªã block -> Ch·ªù

            // === TH·ª∞C HI·ªÜN LOGIC DI CHUY·ªÇN ===
            // 1. N·∫øu xe ·ªü slot cu·ªëi -> Th·ª≠ di chuy·ªÉn sang TR·∫†M M·ªöI
            if (isLastSlot) {
                // --- B∆Ø·ªöC 1: X√ÅC ƒê·ªäNH TR·∫†NG TH√ÅI TI·ªÄM NƒÇNG (potentialStatus) SAU KHI R·ªúI TR·∫†M ---
                let potentialStatus = vehicle.status;
                let potentialErrorTypeId = vehicle.current_error_type_id;

                // a. R·ªùi P/M Inspection (10): Random l·ªói n·∫øu ·ªü v√≤ng 0 ho·∫∑c 1 V√Ä ch∆∞a c√≥ l·ªói
                if (vehicle.current_station_id === inspection_station_id) {
                    if (vehicle.primer_lap_count <= 1 && vehicle.current_error_type_id === null && Math.random() < inspection_failure_rate) {
                        potentialStatus = 'rework';
                        if (errorTypesData.length > 0) { potentialErrorTypeId = errorTypesData[Math.floor(Math.random() * errorTypesData.length)].id; } else { potentialErrorTypeId = null; }
                    } else { if (potentialStatus !== 'rework') { potentialStatus = 'ok'; potentialErrorTypeId = null; } } // Gi·ªØ rework n·∫øu ƒë√£ c√≥, c√≤n l·∫°i th√†nh OK
                    stateChanged = true;
                }
                // b. R·ªùi Topcoat Inspection (17): Random l·ªói n·∫øu ch∆∞a c√≥ l·ªói
                else if (vehicle.current_station_id === TOPCOAT_INSPECTION_ID) {
                    if (vehicle.current_error_type_id === null && Math.random() < TOPCOAT_FAILURE_RATE) {
                        potentialStatus = 'rework';
                        if (errorTypesData.length > 0) { potentialErrorTypeId = errorTypesData[Math.floor(Math.random() * errorTypesData.length)].id; } else { potentialErrorTypeId = null; }
                    } else { if (potentialStatus !== 'rework') { potentialStatus = 'ok'; potentialErrorTypeId = null; } } // Gi·ªØ rework n·∫øu ƒë√£ c√≥, c√≤n l·∫°i th√†nh OK
                    stateChanged = true;
                }
                // c. R·ªùi P/M Repair (23): Lu√¥n OK
                else if (vehicle.current_station_id === repair_station_id) { potentialStatus = 'ok'; potentialErrorTypeId = null; }
                // d. R·ªùi Offline Repair (25): Random OK ho·∫∑c rework_offline
                else if (vehicle.current_station_id === OFFLINE_REPAIR_ID) { if (Math.random() < OFFLINE_REPAIR_SUCCESS_RATE) { potentialStatus = 'ok'; potentialErrorTypeId = null; } else { potentialStatus = 'rework_offline'; } stateChanged = true; }
                // e. R·ªùi Wait Recoat (24): Lu√¥n OK
                else if (vehicle.current_station_id === WAIT_RECOAT_ID) { potentialStatus = 'ok'; potentialErrorTypeId = null; }
                // --- K·∫æT TH√öC B∆Ø·ªöC 1 ---

                // --- B∆Ø·ªöC 2: L·∫§Y TR·∫†M TI·∫æP THEO D·ª∞A TR√äN TR·∫†NG TH√ÅI TI·ªÄM NƒÇNG ---
                const tempVehicleForRouting = { ...vehicle, status: potentialStatus };
                const nextStationId = getNextStationId(tempVehicleForRouting);
                // --- K·∫æT TH√öC B∆Ø·ªöC 2 ---

                let newLapCount = vehicle.primer_lap_count;
                // TƒÉng v√≤ng l·∫∑p n·∫øu ƒëi t·ª´ 14 -> 9
                if (vehicle.current_station_id === 14 && nextStationId === 9) {
                    newLapCount++;
                }

                // X·ª≠ l√Ω ra kh·ªèi chuy·ªÅn (tr·∫°m 22 -> null)
                if (nextStationId === null) {
                    // DEBUG 22: Log khi chu·∫©n b·ªã x√≥a xe
                    console.log(`[DEBUG 22 Exit Attempt] Xe ${vehicle.body_id} t·∫°i slot ${vehicle.slot_position} tr·∫°m 22. ƒê√≠ch ƒë·∫øn = null. Chu·∫©n b·ªã th√™m l·ªánh DELETE.`);
                    dbUpdates.push({ query: 'DELETE FROM vehicles WHERE body_id = ?', params: [vehicle.body_id], vehicleIdToRemove: vehicle.body_id });
                    await logEvent('success', `Ho√†n th√†nh: ${vehicle.body_id}.`);
                    stateChanged = true;
                    // DEBUG 22: Log sau khi th√™m l·ªánh DELETE
                    console.log(`[DEBUG 22 Exit Queued] Xe ${vehicle.body_id} - ƒê√£ th√™m l·ªánh DELETE v√†o dbUpdates.`);
                    continue; // R·∫•t quan tr·ªçng: B·ªè qua ph·∫ßn c√≤n l·∫°i, x·ª≠ l√Ω xe ti·∫øp theo
                }
                // Ki·ªÉm tra tr·∫°m ti·∫øp theo
                const nextStation = stationsData[nextStationId];
                if (!nextStation || !nextStation.capacity || nextStation.capacity <= 0) { await logEvent('error', `L·ªói logic tr·∫°m ti·∫øp theo ${nextStationId} cho ${vehicle.body_id}.`); vehicle.status = 'error_logic'; stateChanged = true; continue; }
                // Ki·ªÉm tra slot 0 c·ªßa tr·∫°m ti·∫øp theo c√≥ tr·ªëng kh√¥ng
                const isNextSlotZeroFree = !activeVehicles.some(v => v.current_station_id === nextStationId && v.slot_position === 0);

                if (isNextSlotZeroFree) { // === DI CHUY·ªÇN TR·∫†M TH√ÄNH C√îNG ===
                    const nextSlot = 0;
                    // Chu·∫©n b·ªã c·∫≠p nh·∫≠t DB v·ªõi tr·∫°ng th√°i v√† l·ªói cu·ªëi c√πng (potential)
                    const updateQuery = 'UPDATE vehicles SET current_station_id = ?, slot_position = ?, primer_lap_count = ?, status = ?, current_error_type_id = ? WHERE body_id = ?';
                    const updateParams = [nextStationId, nextSlot, newLapCount, potentialStatus, potentialErrorTypeId, vehicle.body_id];
                    dbUpdates.push({ query: updateQuery, params: updateParams });

                    const oldStatus = vehicle.status; const oldStationId = vehicle.current_station_id;

                    // C·∫≠p nh·∫≠t b·ªô nh·ªõ
                    vehicle.current_station_id = nextStationId; vehicle.slot_position = nextSlot;
                    vehicle.slotEntryTime = now; vehicle.stationEntryTime = now; vehicle.primer_lap_count = newLapCount;
                    vehicle.status = potentialStatus; vehicle.current_error_type_id = potentialErrorTypeId;
                    vehicle.current_error_name = errorTypesData.find(et => et.id === potentialErrorTypeId)?.name || null;
                    stateChanged = true;

                    // Log v√† Alert d·ª±a tr√™n s·ª± thay ƒë·ªïi tr·∫°ng th√°i
                    const errorName = vehicle.current_error_name || 'Kh√¥ng x√°c ƒë·ªãnh';
                    // Ch·ªâ log/alert l·ªói khi tr·∫°ng th√°i M·ªöI l√† rework/rework_offline V√Ä TR∆Ø·ªöC ƒê√ì kh√¥ng ph·∫£i
                    if (oldStationId === inspection_station_id && vehicle.status === 'rework' && oldStatus !== 'rework') {
                        await logEvent('warning', `Xe ${vehicle.body_id} l·ªói [${errorName}] (V√≤ng ${vehicle.primer_lap_count}). ƒê√£ chuy·ªÉn ƒë·∫øn PM Repair.`);
                        if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} l·ªói [${errorName}] (V√≤ng ${vehicle.primer_lap_count}). Chuy·ªÉn ƒë·∫øn PM Repair.`, type: 'error' });
                    } else if (oldStationId === TOPCOAT_INSPECTION_ID && vehicle.status === 'rework' && oldStatus !== 'rework') {
                         await logEvent('warning', `Xe ${vehicle.body_id} l·ªói [${errorName}]. ƒê√£ chuy·ªÉn ƒë·∫øn Offline Repair.`);
                         if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} l·ªói [${errorName}]. Chuy·ªÉn ƒë·∫øn Offline Repair.`, type: 'error' });
                    } else if (oldStationId === OFFLINE_REPAIR_ID && vehicle.status === 'rework_offline' && oldStatus !== 'rework_offline') {
                        await logEvent('error', `Xe ${vehicle.body_id} kh√¥ng th·ªÉ s·ª≠a l·ªói [${errorName}], ƒë√£ chuy·ªÉn ƒë·∫øn Wait Recoat.`);
                        if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} kh√¥ng th·ªÉ s·ª≠a l·ªói [${errorName}], chuy·ªÉn ƒë·∫øn Wait Recoat.`, type: 'error' });
                    }
                    // Log khi s·ª≠a xong (chuy·ªÉn t·ª´ l·ªói -> ok)
                    else if (oldStationId === repair_station_id && vehicle.status === 'ok' && oldStatus !== 'ok') {
                        await logEvent('info', `Xe ${vehicle.body_id} ƒë√£ ho√†n th√†nh PM Repair.`);
                    } else if (oldStationId === OFFLINE_REPAIR_ID && vehicle.status === 'ok' && oldStatus !== 'ok') {
                        await logEvent('info', `Xe ${vehicle.body_id} ƒë√£ s·ª≠a xong t·∫°i Offline Repair.`);
                    } else if (oldStationId === WAIT_RECOAT_ID && vehicle.status === 'ok' && oldStatus !== 'ok') {
                         await logEvent('info', `Xe ${vehicle.body_id} ƒë√£ ho√†n th√†nh Wait Recoat.`);
                    }
                    // Log khi quay l·∫°i Primer Storage
                    else if (oldStationId === 14 && vehicle.current_station_id === 9 && vehicle.primer_lap_count > 0) {
                        await logEvent('info', `${vehicle.body_id} ho√†n th√†nh l∆∞·ª£t ${vehicle.primer_lap_count-1}, quay l·∫°i Primer Storage (l∆∞·ª£t ${vehicle.primer_lap_count}).`);
                    }

                } else { // === B·ªä BLOCK KHI CHUY·ªÇN TR·∫†M ===
                    if (vehicle.status !== 'blocked') {
                        if (vehicle.status === 'ok') { vehicle.status = 'blocked'; } // Ch·ªâ ƒë·ªïi th√†nh blocked n·∫øu ƒëang l√† 'ok'
                        stateChanged = true;
                    }
                }

            // 2. N·∫øu kh√¥ng ph·∫£i slot cu·ªëi -> Th·ª≠ di chuy·ªÉn sang SLOT M·ªöI trong c√πng tr·∫°m
            } else {
                 const nextSlotPosition = vehicle.slot_position + 1;
                 const isNextSlotFree = !activeVehicles.some(v => v.current_station_id === vehicle.current_station_id && v.slot_position === nextSlotPosition);

                 // DEBUG 22: Log khi th·ª≠ di chuy·ªÉn slot b√™n trong tr·∫°m 22
                 if (vehicle.current_station_id === 22) {
                     console.log(`[DEBUG 22 Slot Move Check] Xe ${vehicle.body_id} (Slot ${vehicle.slot_position}) mu·ªën ƒë·∫øn Slot ${nextSlotPosition}. Slot tr·ªëng: ${isNextSlotFree}`);
                 }

                 if (isNextSlotFree) { // === DI CHUY·ªÇN SLOT TH√ÄNH C√îNG ===
                     vehicle.slot_position = nextSlotPosition; vehicle.slotEntryTime = now;
                     // N·∫øu ƒëang b·ªã block v√† kh√¥ng ph·∫£i l·ªói s·ª≠a ch·ªØa -> th√†nh 'ok'
                     if (vehicle.status === 'blocked' && vehicle.status !== 'rework' && vehicle.status !== 'rework_offline') { vehicle.status = 'ok'; }
                     // Gi·ªØ nguy√™n tr·∫°ng th√°i l·ªói khi ch·ªâ chuy·ªÉn slot
                     stateChanged = true;
                     // DEBUG 22: Log khi di chuy·ªÉn slot th√†nh c√¥ng
                     if (vehicle.current_station_id === 22) {
                         console.log(`[DEBUG 22 Slot Move Success] Xe ${vehicle.body_id} ƒë√£ chuy·ªÉn ƒë·∫øn Slot ${vehicle.slot_position}.`);
                     }
                 } else { // === B·ªä BLOCK KHI CHUY·ªÇN SLOT ===
                      // DEBUG 22: Log khi b·ªã block khi chuy·ªÉn slot
                      if (vehicle.current_station_id === 22) {
                           console.log(`[DEBUG 22 Slot Move Blocked] Xe ${vehicle.body_id} b·ªã block khi c·ªë ƒë·∫øn Slot ${nextSlotPosition}.`);
                      }
                      if (vehicle.status !== 'blocked') {
                           if (vehicle.status === 'ok') { vehicle.status = 'blocked'; } // Ch·ªâ ƒë·ªïi th√†nh blocked n·∫øu ƒëang l√† 'ok'
                           stateChanged = true;
                      }
                 }
            }
        } // H·∫øt for vehicle
    } // H·∫øt for station

    // --- TH·ª∞C HI·ªÜN DB UPDATES ---
    if (dbUpdates.length > 0) {
        let connection;
        try {
            connection = await pool.getConnection(); await connection.beginTransaction();
            for (const update of dbUpdates) {
                // DEBUG 22: Log l·ªánh DB s·∫Øp th·ª±c thi (n·∫øu l√† DELETE)
                if (update.query.startsWith('DELETE') && update.params[0].startsWith('BD')) { // Gi·∫£ ƒë·ªãnh body_id b·∫Øt ƒë·∫ßu b·∫±ng BD
                     console.log(`[DEBUG 22 DB Delete Executing] Chu·∫©n b·ªã x√≥a xe: ${update.params[0]}`);
                }
                await connection.execute(update.query, update.params);
                if(update.vehicleIdToRemove){
                    // DEBUG 22: Log khi x√≥a kh·ªèi b·ªô nh·ªõ sau DB success
                    console.log(`[DEBUG 22 Memory Remove] ƒê√£ x√≥a xe ${update.vehicleIdToRemove} kh·ªèi activeVehicles.`);
                    activeVehicles = activeVehicles.filter(v => v.body_id !== update.vehicleIdToRemove);
                }
            }
            await connection.commit();
             // DEBUG 22: Log khi transaction th√†nh c√¥ng
             if (dbUpdates.some(upd => upd.query.startsWith('DELETE'))) {
                 console.log("[DEBUG 22 DB Transaction Success] Transaction bao g·ªìm l·ªánh DELETE ƒë√£ commit th√†nh c√¥ng.");
             }
        } catch (error) {
            console.error("‚ùå L·ªói DB Transaction:", error);
            await logEvent('error', `L·ªói DB Transaction: ${error.message}`);
             // DEBUG 22: Log khi transaction th·∫•t b·∫°i
             if (dbUpdates.some(upd => upd.query.startsWith('DELETE'))) {
                 console.error("[DEBUG 22 DB Transaction FAILED] Transaction bao g·ªìm l·ªánh DELETE ƒë√£ b·ªã rollback!");
             }
            if (connection) { try { await connection.rollback(); } catch (rbError) { console.error("Rollback failed:", rbError); } }
        } finally {
            if (connection) { try { connection.release(); } catch (rlError) { console.error("Release failed:", rlError); } }
        }
    }

    // Broadcast n·∫øu c√≥ thay ƒë·ªïi v√† ƒë·∫∑t l·ªãch cho tick ti·∫øp theo
    if (stateChanged) { updateAndBroadcastState(); }
    if (simulationIntervalId) { simulationIntervalId = setTimeout(simulationTick, SIMULATION_TICK_RATE); }
}

// --- KH·ªûI T·∫†O SERVICE ---
async function initialize(socketIoInstance, dbPool) {
    io = socketIoInstance; pool = dbPool;
    try {
        const [stationRows] = await pool.execute('SELECT * FROM stations ORDER BY id ASC'); stationsData = {}; stationRows.forEach(station => { stationsData[station.id] = { ...station, vehicles: [] }; });
        try { const [errorTypeRows] = await pool.execute('SELECT id, name FROM error_types'); errorTypesData = errorTypeRows; console.log(`‚úÖ Service: ƒê√£ t·∫£i ${errorTypesData.length} lo·∫°i l·ªói.`); } catch (error) { console.error("‚ùå L·ªói t·∫£i error_types:", error); errorTypesData = []; }
        const [vehicleRows] = await pool.execute(SELECT_VEHICLES_QUERY + " ORDER BY v.current_station_id ASC, v.created_at ASC"); activeVehicles = vehicleRows.map(v => ({ ...v, slotEntryTime: Date.now(), stationEntryTime: Date.now() }));
        console.log('‚úÖ Service: ƒê√£ t·∫£i d·ªØ li·ªáu th√†nh c√¥ng.'); await logEvent('info', 'H·ªá th·ªëng ƒë√£ kh·ªüi t·∫°o.');
        updateAndBroadcastState(); startSimulation();
    } catch (error) { console.error("‚ùå L·ªói kh·ªüi t·∫°o:", error); await logEvent('error', `L·ªói kh·ªüi t·∫°o: ${error.message}`); }
}

// --- TH√äM XE M·ªöI V√ÄO BUFFER ---
async function addVehicle(body_id) {
    try {
        if (activeVehicles.some(v => v.body_id === body_id)) throw new Error(`Xe "${body_id}" ƒë√£ c√≥.`);
        const [bodyRows] = await pool.execute('SELECT * FROM car_bodies WHERE body_id = ?', [body_id]); if (bodyRows.length === 0) throw new Error(`M√£ th√¢n xe "${body_id}" kh√¥ng t·ªìn t·∫°i.`);
        await pool.execute('INSERT INTO vehicles (body_id, current_station_id, slot_position, status, primer_lap_count, current_error_type_id) VALUES (?, ?, ?, ?, ?, ?)', [body_id, 0, 0, 'ok', 0, null]);
        const message = `Th√™m xe m·ªõi: ${body_id} v√†o buffer ch·ªù.`; await logEvent('success', message);
        const [newVehicleRows] = await pool.execute(`${SELECT_VEHICLES_QUERY} WHERE v.body_id = ?`, [body_id]);
        if (newVehicleRows.length > 0) { const newVehicleData = { ...newVehicleRows[0], slotEntryTime: Date.now(), stationEntryTime: Date.now(), current_error_name: null }; activeVehicles.push(newVehicleData); }
        updateAndBroadcastState();
    } catch (error) { console.error(`‚ùå L·ªói th√™m xe ${body_id}: ${error.message}`); await logEvent('error', `L·ªói th√™m xe ${body_id}: ${error.message}`); throw error; }
}

// --- ƒêI·ªÄU KHI·ªÇN M√î PH·ªéNG ---
function startSimulation() { if (simulationIntervalId) return; console.log(`‚ñ∂Ô∏è M√¥ ph·ªèng b·∫Øt ƒë·∫ßu (tick ${SIMULATION_TICK_RATE}ms).`); logEvent('info', `M√¥ ph·ªèng b·∫Øt ƒë·∫ßu (tick ${SIMULATION_TICK_RATE}ms).`); simulationIntervalId = setTimeout(simulationTick, SIMULATION_TICK_RATE); }
function stopSimulation() { if (simulationIntervalId) { clearTimeout(simulationIntervalId); simulationIntervalId = null; console.log('‚èπÔ∏è M√¥ ph·ªèng ƒë√£ d·ª´ng.'); logEvent('info', 'M√¥ ph·ªèng ƒë√£ d·ª´ng.'); } }

// --- D·ª™NG KH·∫®N C·∫§P V√Ä X√ìA XE ---
async function emergencyStopAndClear() {
    stopSimulation();
    const message = 'D·ª´ng kh·∫©n c·∫•p: D√¢y chuy·ªÅn d·ª´ng, xe ƒë√£ x√≥a.'; console.log(`üî• ${message}`); await logEvent('error', message);
    let connection;
    try {
        connection = await pool.getConnection(); await connection.beginTransaction();
        await connection.execute('SET FOREIGN_KEY_CHECKS = 0;'); await connection.execute('TRUNCATE TABLE vehicles'); await connection.execute('SET FOREIGN_KEY_CHECKS = 1;');
        await connection.commit();
        activeVehicles = []; updateAndBroadcastState(); console.log('‚úÖ ƒê√£ x√≥a xe th√†nh c√¥ng.');
    } catch (error) { console.error("‚ùå L·ªói d·ª´ng kh·∫©n c·∫•p:", error); await logEvent('error', `L·ªói d·ª´ng kh·∫©n c·∫•p: ${error.message}`); if(connection) await connection.rollback(); }
    finally { if(connection) connection.release(); }
}

// --- X√ìA XE TH·ª¶ C√îNG ---
async function removeVehicle(body_id) {
    console.log(`[RemoveVehicle] Y√™u c·∫ßu x√≥a xe: ${body_id}`);
    const vehicleIndex = activeVehicles.findIndex(v => v.body_id === body_id);
    if (vehicleIndex === -1) throw new Error(`Xe "${body_id}" kh√¥ng t√¨m th·∫•y.`);
    const vehicleToRemove = activeVehicles[vehicleIndex]; const stationId = vehicleToRemove.current_station_id;
    const wasRunning = !!simulationIntervalId; if(wasRunning) stopSimulation();
    let connection;
    try {
        connection = await pool.getConnection(); await connection.beginTransaction();
        await connection.execute('DELETE FROM vehicles WHERE body_id = ?', [body_id]);
        activeVehicles.splice(vehicleIndex, 1);
        stateChanged = true;
        if (stationId !== 0) {
            const remainingVehicles = activeVehicles.filter(v => v.current_station_id === stationId).sort((a, b) => a.slot_position - b.slot_position);
            const shiftUpdates = []; let needsDbShiftUpdate = false;
            remainingVehicles.forEach((v, newIndex) => { if (v.slot_position !== newIndex) { shiftUpdates.push(connection.execute('UPDATE vehicles SET slot_position = ? WHERE body_id = ?', [newIndex, v.body_id])); v.slot_position = newIndex; needsDbShiftUpdate = true; } });
            if (needsDbShiftUpdate) { await Promise.all(shiftUpdates); }
        }
        await connection.commit(); console.log(`[RemoveVehicle] X√≥a v√† d·ªãch chuy·ªÉn xe ${body_id} th√†nh c√¥ng.`);
        await logEvent('warning', `Xe ${body_id} ƒë√£ b·ªã x√≥a kh·ªèi tr·∫°m/buffer.`); updateAndBroadcastState();
    } catch (error) { console.error(`‚ùå REMOVE_VEHICLE_ERROR (${body_id}): ${error.message}`); await logEvent('error', `L·ªói khi x√≥a xe ${body_id}: ${error.message}`); if(connection) await connection.rollback(); throw error; }
    finally { if(connection) connection.release(); if(wasRunning) startSimulation(); }
}

// --- B√ÅO L·ªñI M√ÅY M√ìC ---
function reportOperationalError(stationId) {
    const station = stationsData[stationId];
    if (station) {
        const message = `S·ª± c·ªë m√°y m√≥c: ${station.name}.`; console.log(`üö® ${message}`); logEvent('error', message); io.emit('operational-error', { stationName: station.name, message: message });
        stopSimulation();
        activeVehicles.filter(v => v.current_station_id === stationId).forEach(v => { v.status = 'error_stoppage'; }); updateAndBroadcastState();
    }
}

// --- LOGIC ƒê·ªäNH TUY·∫æN XE ---
function getNextStationId(vehicle) {
    // Kh√¥ng di chuy·ªÉn n·∫øu ƒëang d·ª´ng do l·ªói m√°y m√≥c/logic
    if (['error_stoppage', 'error_logic'].includes(vehicle.status)) { return vehicle.current_station_id; }
    if (vehicle.current_station_id === 0) { return 0; } // Xe buffer kh√¥ng t·ª± ƒëi

    const currentStationId = vehicle.current_station_id;

    // --- Lu·ªìng s·ª≠a ch·ªØa ---
    if (currentStationId === repair_station_id) { return post_repair_destination_id; } // 23 -> 12
    if (currentStationId === inspection_station_id && vehicle.status === 'rework') { return repair_station_id; } // 10 (L·ªói) -> 23
    if (currentStationId === TOPCOAT_INSPECTION_ID && vehicle.status === 'rework') { return OFFLINE_REPAIR_ID; } // 17 (L·ªói) -> 25
    if (currentStationId === OFFLINE_REPAIR_ID) { // R·ªùi tr·∫°m 25
        if (vehicle.status === 'ok') { return FINISHING_ID; } // S·ª≠a OK -> 18
        if (vehicle.status === 'rework_offline') { return WAIT_RECOAT_ID; } // S·ª≠a h·ªèng -> 24
        return currentStationId; // An to√†n: Gi·ªØ l·∫°i n·∫øu status l·∫°
    }
    if (currentStationId === WAIT_RECOAT_ID) { return post_repair_destination_id; } // 24 -> 12
    // --- K·∫øt th√∫c lu·ªìng s·ª≠a ch·ªØa ---

    // Lu·ªìng s∆°n l√≥t
    if (currentStationId === 14) {
        const destination = vehicle.primer_lap_count < 1 ? 9 : 15;
        return destination;
    }

    // --- Lu·ªìng ch√≠nh ---
    const mainFlowPath = {
        1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10,
        10: 11, // 10 (OK) -> 11
        11: 12, 12: 13, 13: 14, /* 14 */ 15: 17,
        17: 18, // 17 (OK) -> 18
        18: 19, 19: 20, 20: 22, 22: null // K·∫øt th√∫c
    };
    return mainFlowPath[currentStationId] !== undefined ? mainFlowPath[currentStationId] : null;
}


// --- L·∫§Y TR·∫†NG TH√ÅI HI·ªÜN T·∫†I ƒê·ªÇ G·ª¨I CHO CLIENT ---
function getState() {
    // Ch·ªâ g·ª≠i c√°c tr∆∞·ªùng c·∫ßn thi·∫øt cho client
    const cleanVehicles = activeVehicles.map(v => {
        // B·ªè qua c√°c tr∆∞·ªùng ch·ªâ d√πng ·ªü backend
        const { slotEntryTime, stationEntryTime, timerId, ...vehicleData } = v;
        return vehicleData;
    });
    return {
        stations: Object.values(stationsData), // Chuy·ªÉn object th√†nh m·∫£ng
        vehicles: cleanVehicles
    };
}

// --- G·ª¨I TR·∫†NG TH√ÅI M·ªöI CHO T·∫§T C·∫¢ CLIENT ---
function updateAndBroadcastState() {
    const currentState = getState();
    // G√°n danh s√°ch xe v√†o t·ª´ng tr·∫°m ƒë·ªÉ client d·ªÖ x·ª≠ l√Ω
    currentState.stations.forEach(station => {
        station.vehicles = currentState.vehicles
            .filter(v => v.current_station_id === station.id)
            .sort((a, b) => a.slot_position - b.slot_position); // S·∫Øp x·∫øp theo slot
     });
    io.emit('state-update', currentState); // G·ª≠i qua socket
}

// --- EXPORT C√ÅC H√ÄM C√îNG KHAI ---
module.exports = {
    initialize,
    start: startSimulation,
    stop: stopSimulation,
    addVehicle,
    getState,
    reportOperationalError,
    emergencyStopAndClear,
    removeVehicle,
};
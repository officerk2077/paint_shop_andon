const SIMULATION_TICK_RATE = 1000; // ms - Tần suất chạy vòng lặp mô phỏng

let io; // Instance Socket.IO
let pool; // Instance MySQL connection pool
let stationsData = {}; // Cache dữ liệu các trạm { id: { name, capacity, takt_time, ... } }
let activeVehicles = []; // Danh sách xe đang hoạt động trong bộ nhớ [{ ..., slotEntryTime, stationEntryTime }]
let errorTypesData = []; // Cache danh sách loại lỗi [{ id, name }]
let simulationIntervalId = null; // ID của setTimeout cho vòng lặp tick

// IDs trạm đặc biệt
const OVEN_STATION_IDS = [4, 14];
const inspection_station_id = 10;
const repair_station_id = 23;
const post_repair_destination_id = 12; // Prepare (Đích đến sau khi sửa lỗi Primer/Recoat)
const TOPCOAT_INSPECTION_ID = 17;
const OFFLINE_REPAIR_ID = 25;
const FINISHING_ID = 18;
const WAIT_RECOAT_ID = 24;

// Tỷ lệ lỗi ngẫu nhiên
const inspection_failure_rate = 0.2; // Tỷ lệ lỗi tại P/M Inspection (chỉ 1 lần trong vòng 0 hoặc 1)
const TOPCOAT_FAILURE_RATE = 0.3;    // Tỷ lệ lỗi tại Topcoat Inspection
const OFFLINE_REPAIR_SUCCESS_RATE = 0.9; // Tỷ lệ sửa thành công tại Offline Repair

// Truy vấn SQL lấy thông tin xe bao gồm cả tên lỗi hiện tại (nếu có)
const SELECT_VEHICLES_QUERY = `
    SELECT
        v.*,
        cb.model_name,
        cb.target_color,
        cb.color_hex,
        et.name AS current_error_name
    FROM vehicles v
    JOIN car_bodies cb ON v.body_id = cb.body_id
    LEFT JOIN error_types et ON v.current_error_type_id = et.id
`;

// --- HÀM GHI LOG ---
async function logEvent(type, message) {
    let insertedId = null;
    try {
        const query = 'INSERT INTO logs (type, message) VALUES (?, ?)';
        const [result] = await pool.execute(query, [type, message]);
        insertedId = result.insertId;
    } catch (error) { console.error(`❌ DB Log Error: ${error.message}`); }
    if (insertedId && io) {
        const newLogEntry = { id: insertedId, timestamp: new Date().toISOString(), type: type, message: message };
        io.emit('new-log', newLogEntry); // Phát sự kiện log mới cho client
    }
}

/**
 * Hàm LÕI: Vòng lặp kiểm tra và di chuyển xe, chạy mỗi SIMULATION_TICK_RATE ms
 */
async function simulationTick() {
    const now = Date.now();
    const dbUpdates = []; // Gom các lệnh DB update để chạy transaction
    let stateChanged = false; // Cờ báo hiệu có thay đổi trạng thái cần broadcast
    // console.log(`--- Tick: ${new Date().toLocaleTimeString()} ---`);

    // --- XỬ LÝ BUFFER ẢO (ID 0) ---
    // Đưa xe từ buffer (hàng chờ) vào trạm Loading (ID 1) nếu còn chỗ
    const vehiclesInBuffer = activeVehicles.filter(v => v.current_station_id === 0).sort((a, b) => new Date(a.created_at) - new Date(b.created_at)); // FIFO
    if (vehiclesInBuffer.length > 0) {
        const loadingStation = stationsData[1]; // Trạm Loading
        if (loadingStation && loadingStation.capacity > 0) {
            let occupiedSlotsSet = new Set(activeVehicles.filter(v => v.current_station_id === 1).map(v => v.slot_position));
            let bufferIndex = 0;
            // Cố gắng lấp đầy tất cả slot trống trong cùng 1 tick
            while (bufferIndex < vehiclesInBuffer.length && occupiedSlotsSet.size < loadingStation.capacity) {
                let targetSlotPosition = -1;
                // Tìm slot trống từ cuối lên (ưu tiên slot index cao)
                for (let i = loadingStation.capacity - 1; i >= 0; i--) { if (!occupiedSlotsSet.has(i)) { targetSlotPosition = i; break; } }
                if (targetSlotPosition === -1) break; // Hết slot trống

                const vehicleToLoad = vehiclesInBuffer[bufferIndex];

                // Chuẩn bị cập nhật DB
                const updateQuery = 'UPDATE vehicles SET current_station_id = ?, slot_position = ?, status = ? WHERE body_id = ?';
                dbUpdates.push({ query: updateQuery, params: [1, targetSlotPosition, 'ok', vehicleToLoad.body_id] });

                // Cập nhật bộ nhớ ngay
                const vehicleInActiveList = activeVehicles.find(v => v.id === vehicleToLoad.id);
                if (vehicleInActiveList) {
                    vehicleInActiveList.current_station_id = 1; vehicleInActiveList.slot_position = targetSlotPosition;
                    vehicleInActiveList.slotEntryTime = now; vehicleInActiveList.stationEntryTime = now;
                    vehicleInActiveList.status = 'ok'; // Xe mới vào chuyền luôn 'ok'
                } else { console.error(`Lỗi logic buffer: Không tìm thấy ${vehicleToLoad.body_id}`); bufferIndex++; continue; }

                stateChanged = true;
                await logEvent('info', `Xe ${vehicleToLoad.body_id} vào Loading slot ${targetSlotPosition}.`);
                occupiedSlotsSet.add(targetSlotPosition); // Đánh dấu slot đã chiếm cho lần lặp while tiếp theo
                bufferIndex++; // Xét xe tiếp theo trong buffer
            }
        }
    }

    // --- XỬ LÝ CÁC TRẠM THỰC TẾ (ID > 0) ---
    const activeStationIds = [...new Set(activeVehicles.map(v => v.current_station_id))].filter(id => id !== 0);
    for (const stationId of activeStationIds) {
        const currentStation = stationsData[stationId];
        if (!currentStation) continue;
        // Xử lý xe từ slot cuối lên trước (hệ thống kéo)
        const vehiclesAtStation = activeVehicles.filter(v => v.current_station_id === stationId).sort((a, b) => b.slot_position - a.slot_position);

        for (const vehicle of vehiclesAtStation) {
            if (['error_stoppage', 'error_logic'].includes(vehicle.status)) continue; // Bỏ qua xe lỗi hệ thống
            // Khởi tạo thời gian vào nếu chưa có
            if (!vehicle.slotEntryTime) { vehicle.slotEntryTime = now; stateChanged = true; }
            if (!vehicle.stationEntryTime) { vehicle.stationEntryTime = vehicle.slotEntryTime; stateChanged = true; }
            // Kiểm tra dữ liệu capacity hợp lệ
            if (!currentStation.capacity || currentStation.capacity <= 0) { await logEvent('error', `Lỗi capacity trạm ${currentStation.name}.`); vehicle.status = 'error_logic'; stateChanged = true; continue; }

            // --- TÍNH TOÁN THỜI GIAN CHỜ ---
            let requiredTime = 0, timeElapsed = 0;
            const isOven = OVEN_STATION_IDS.includes(currentStation.id);
            const isLastSlot = vehicle.slot_position === currentStation.capacity - 1;
            const stationTaktTime = currentStation.takt_time || 15000;
            const capacity = currentStation.capacity > 0 ? currentStation.capacity : 1;
            const isSpecialTimeStation = currentStation.id === repair_station_id || currentStation.id === OFFLINE_REPAIR_ID || currentStation.id === WAIT_RECOAT_ID;
            // Lò sấy và trạm sửa chữa (ở slot cuối) dùng tổng thời gian vào trạm
            if ((isOven && isLastSlot) || (isSpecialTimeStation && isLastSlot)) {
                 requiredTime = stationTaktTime; timeElapsed = now - (vehicle.stationEntryTime || now);
             } else { // Các trạm/slot khác dùng thời gian vào slot
                 requiredTime = stationTaktTime / capacity; timeElapsed = now - (vehicle.slotEntryTime || now);
             }

            // --- QUYẾT ĐỊNH CÓ THỬ DI CHUYỂN KHÔNG ---
            let attemptMove = false;
            if (timeElapsed >= requiredTime) { // Đủ thời gian
                attemptMove = true;
                if (vehicle.status === 'blocked') { // Nếu đang block và đủ thời gian, thử reset thành 'ok' (nếu không phải rework)
                    if (vehicle.status !== 'rework' && vehicle.status !== 'rework_offline') { vehicle.status = 'ok'; }
                    stateChanged = true;
                }
            } else if (vehicle.status === 'blocked') { attemptMove = true; } // Đang block -> Vẫn thử di chuyển

            // DEBUG 22: Log trạng thái trước khi quyết định di chuyển
            if (vehicle.current_station_id === 22) {
                 console.log(`[DEBUG 22 PreCheck] Xe ${vehicle.body_id} | Slot: ${vehicle.slot_position} | Status: ${vehicle.status} | Time OK: ${timeElapsed >= requiredTime} | AttemptMove: ${attemptMove}`);
            }

            if (!attemptMove) continue; // Chưa đủ thời gian và không bị block -> Chờ

            // === THỰC HIỆN LOGIC DI CHUYỂN ===
            // 1. Nếu xe ở slot cuối -> Thử di chuyển sang TRẠM MỚI
            if (isLastSlot) {
                // --- BƯỚC 1: XÁC ĐỊNH TRẠNG THÁI TIỀM NĂNG (potentialStatus) SAU KHI RỜI TRẠM ---
                let potentialStatus = vehicle.status;
                let potentialErrorTypeId = vehicle.current_error_type_id;

                // a. Rời P/M Inspection (10): Random lỗi nếu ở vòng 0 hoặc 1 VÀ chưa có lỗi
                if (vehicle.current_station_id === inspection_station_id) {
                    if (vehicle.primer_lap_count <= 1 && vehicle.current_error_type_id === null && Math.random() < inspection_failure_rate) {
                        potentialStatus = 'rework';
                        if (errorTypesData.length > 0) { potentialErrorTypeId = errorTypesData[Math.floor(Math.random() * errorTypesData.length)].id; } else { potentialErrorTypeId = null; }
                    } else { if (potentialStatus !== 'rework') { potentialStatus = 'ok'; potentialErrorTypeId = null; } } // Giữ rework nếu đã có, còn lại thành OK
                    stateChanged = true;
                }
                // b. Rời Topcoat Inspection (17): Random lỗi nếu chưa có lỗi
                else if (vehicle.current_station_id === TOPCOAT_INSPECTION_ID) {
                    if (vehicle.current_error_type_id === null && Math.random() < TOPCOAT_FAILURE_RATE) {
                        potentialStatus = 'rework';
                        if (errorTypesData.length > 0) { potentialErrorTypeId = errorTypesData[Math.floor(Math.random() * errorTypesData.length)].id; } else { potentialErrorTypeId = null; }
                    } else { if (potentialStatus !== 'rework') { potentialStatus = 'ok'; potentialErrorTypeId = null; } } // Giữ rework nếu đã có, còn lại thành OK
                    stateChanged = true;
                }
                // c. Rời P/M Repair (23): Luôn OK
                else if (vehicle.current_station_id === repair_station_id) { potentialStatus = 'ok'; potentialErrorTypeId = null; }
                // d. Rời Offline Repair (25): Random OK hoặc rework_offline
                else if (vehicle.current_station_id === OFFLINE_REPAIR_ID) { if (Math.random() < OFFLINE_REPAIR_SUCCESS_RATE) { potentialStatus = 'ok'; potentialErrorTypeId = null; } else { potentialStatus = 'rework_offline'; } stateChanged = true; }
                // e. Rời Wait Recoat (24): Luôn OK
                else if (vehicle.current_station_id === WAIT_RECOAT_ID) { potentialStatus = 'ok'; potentialErrorTypeId = null; }
                // --- KẾT THÚC BƯỚC 1 ---

                // --- BƯỚC 2: LẤY TRẠM TIẾP THEO DỰA TRÊN TRẠNG THÁI TIỀM NĂNG ---
                const tempVehicleForRouting = { ...vehicle, status: potentialStatus };
                const nextStationId = getNextStationId(tempVehicleForRouting);
                // --- KẾT THÚC BƯỚC 2 ---

                let newLapCount = vehicle.primer_lap_count;
                // Tăng vòng lặp nếu đi từ 14 -> 9
                if (vehicle.current_station_id === 14 && nextStationId === 9) {
                    newLapCount++;
                }

                // Xử lý ra khỏi chuyền (trạm 22 -> null)
                if (nextStationId === null) {
                    // DEBUG 22: Log khi chuẩn bị xóa xe
                    console.log(`[DEBUG 22 Exit Attempt] Xe ${vehicle.body_id} tại slot ${vehicle.slot_position} trạm 22. Đích đến = null. Chuẩn bị thêm lệnh DELETE.`);
                    dbUpdates.push({ query: 'DELETE FROM vehicles WHERE body_id = ?', params: [vehicle.body_id], vehicleIdToRemove: vehicle.body_id });
                    await logEvent('success', `Hoàn thành: ${vehicle.body_id}.`);
                    stateChanged = true;
                    // DEBUG 22: Log sau khi thêm lệnh DELETE
                    console.log(`[DEBUG 22 Exit Queued] Xe ${vehicle.body_id} - Đã thêm lệnh DELETE vào dbUpdates.`);
                    continue; // Rất quan trọng: Bỏ qua phần còn lại, xử lý xe tiếp theo
                }
                // Kiểm tra trạm tiếp theo
                const nextStation = stationsData[nextStationId];
                if (!nextStation || !nextStation.capacity || nextStation.capacity <= 0) { await logEvent('error', `Lỗi logic trạm tiếp theo ${nextStationId} cho ${vehicle.body_id}.`); vehicle.status = 'error_logic'; stateChanged = true; continue; }
                // Kiểm tra slot 0 của trạm tiếp theo có trống không
                const isNextSlotZeroFree = !activeVehicles.some(v => v.current_station_id === nextStationId && v.slot_position === 0);

                if (isNextSlotZeroFree) { // === DI CHUYỂN TRẠM THÀNH CÔNG ===
                    const nextSlot = 0;
                    // Chuẩn bị cập nhật DB với trạng thái và lỗi cuối cùng (potential)
                    const updateQuery = 'UPDATE vehicles SET current_station_id = ?, slot_position = ?, primer_lap_count = ?, status = ?, current_error_type_id = ? WHERE body_id = ?';
                    const updateParams = [nextStationId, nextSlot, newLapCount, potentialStatus, potentialErrorTypeId, vehicle.body_id];
                    dbUpdates.push({ query: updateQuery, params: updateParams });

                    const oldStatus = vehicle.status; const oldStationId = vehicle.current_station_id;

                    // Cập nhật bộ nhớ
                    vehicle.current_station_id = nextStationId; vehicle.slot_position = nextSlot;
                    vehicle.slotEntryTime = now; vehicle.stationEntryTime = now; vehicle.primer_lap_count = newLapCount;
                    vehicle.status = potentialStatus; vehicle.current_error_type_id = potentialErrorTypeId;
                    vehicle.current_error_name = errorTypesData.find(et => et.id === potentialErrorTypeId)?.name || null;
                    stateChanged = true;

                    // Log và Alert dựa trên sự thay đổi trạng thái
                    const errorName = vehicle.current_error_name || 'Không xác định';
                    // Chỉ log/alert lỗi khi trạng thái MỚI là rework/rework_offline VÀ TRƯỚC ĐÓ không phải
                    if (oldStationId === inspection_station_id && vehicle.status === 'rework' && oldStatus !== 'rework') {
                        await logEvent('warning', `Xe ${vehicle.body_id} lỗi [${errorName}] (Vòng ${vehicle.primer_lap_count}). Đã chuyển đến PM Repair.`);
                        if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} lỗi [${errorName}] (Vòng ${vehicle.primer_lap_count}). Chuyển đến PM Repair.`, type: 'error' });
                    } else if (oldStationId === TOPCOAT_INSPECTION_ID && vehicle.status === 'rework' && oldStatus !== 'rework') {
                         await logEvent('warning', `Xe ${vehicle.body_id} lỗi [${errorName}]. Đã chuyển đến Offline Repair.`);
                         if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} lỗi [${errorName}]. Chuyển đến Offline Repair.`, type: 'error' });
                    } else if (oldStationId === OFFLINE_REPAIR_ID && vehicle.status === 'rework_offline' && oldStatus !== 'rework_offline') {
                        await logEvent('error', `Xe ${vehicle.body_id} không thể sửa lỗi [${errorName}], đã chuyển đến Wait Recoat.`);
                        if (io) io.emit('vehicle-rework-alert', { message: `Xe ${vehicle.body_id} không thể sửa lỗi [${errorName}], chuyển đến Wait Recoat.`, type: 'error' });
                    }
                    // Log khi sửa xong (chuyển từ lỗi -> ok)
                    else if (oldStationId === repair_station_id && vehicle.status === 'ok' && oldStatus !== 'ok') {
                        await logEvent('info', `Xe ${vehicle.body_id} đã hoàn thành PM Repair.`);
                    } else if (oldStationId === OFFLINE_REPAIR_ID && vehicle.status === 'ok' && oldStatus !== 'ok') {
                        await logEvent('info', `Xe ${vehicle.body_id} đã sửa xong tại Offline Repair.`);
                    } else if (oldStationId === WAIT_RECOAT_ID && vehicle.status === 'ok' && oldStatus !== 'ok') {
                         await logEvent('info', `Xe ${vehicle.body_id} đã hoàn thành Wait Recoat.`);
                    }
                    // Log khi quay lại Primer Storage
                    else if (oldStationId === 14 && vehicle.current_station_id === 9 && vehicle.primer_lap_count > 0) {
                        await logEvent('info', `${vehicle.body_id} hoàn thành lượt ${vehicle.primer_lap_count-1}, quay lại Primer Storage (lượt ${vehicle.primer_lap_count}).`);
                    }

                } else { // === BỊ BLOCK KHI CHUYỂN TRẠM ===
                    if (vehicle.status !== 'blocked') {
                        if (vehicle.status === 'ok') { vehicle.status = 'blocked'; } // Chỉ đổi thành blocked nếu đang là 'ok'
                        stateChanged = true;
                    }
                }

            // 2. Nếu không phải slot cuối -> Thử di chuyển sang SLOT MỚI trong cùng trạm
            } else {
                 const nextSlotPosition = vehicle.slot_position + 1;
                 const isNextSlotFree = !activeVehicles.some(v => v.current_station_id === vehicle.current_station_id && v.slot_position === nextSlotPosition);

                 // DEBUG 22: Log khi thử di chuyển slot bên trong trạm 22
                 if (vehicle.current_station_id === 22) {
                     console.log(`[DEBUG 22 Slot Move Check] Xe ${vehicle.body_id} (Slot ${vehicle.slot_position}) muốn đến Slot ${nextSlotPosition}. Slot trống: ${isNextSlotFree}`);
                 }

                 if (isNextSlotFree) { // === DI CHUYỂN SLOT THÀNH CÔNG ===
                     vehicle.slot_position = nextSlotPosition; vehicle.slotEntryTime = now;
                     // Nếu đang bị block và không phải lỗi sửa chữa -> thành 'ok'
                     if (vehicle.status === 'blocked' && vehicle.status !== 'rework' && vehicle.status !== 'rework_offline') { vehicle.status = 'ok'; }
                     // Giữ nguyên trạng thái lỗi khi chỉ chuyển slot
                     stateChanged = true;
                     // DEBUG 22: Log khi di chuyển slot thành công
                     if (vehicle.current_station_id === 22) {
                         console.log(`[DEBUG 22 Slot Move Success] Xe ${vehicle.body_id} đã chuyển đến Slot ${vehicle.slot_position}.`);
                     }
                 } else { // === BỊ BLOCK KHI CHUYỂN SLOT ===
                      // DEBUG 22: Log khi bị block khi chuyển slot
                      if (vehicle.current_station_id === 22) {
                           console.log(`[DEBUG 22 Slot Move Blocked] Xe ${vehicle.body_id} bị block khi cố đến Slot ${nextSlotPosition}.`);
                      }
                      if (vehicle.status !== 'blocked') {
                           if (vehicle.status === 'ok') { vehicle.status = 'blocked'; } // Chỉ đổi thành blocked nếu đang là 'ok'
                           stateChanged = true;
                      }
                 }
            }
        } // Hết for vehicle
    } // Hết for station

    // --- THỰC HIỆN DB UPDATES ---
    if (dbUpdates.length > 0) {
        let connection;
        try {
            connection = await pool.getConnection(); await connection.beginTransaction();
            for (const update of dbUpdates) {
                // DEBUG 22: Log lệnh DB sắp thực thi (nếu là DELETE)
                if (update.query.startsWith('DELETE') && update.params[0].startsWith('BD')) { // Giả định body_id bắt đầu bằng BD
                     console.log(`[DEBUG 22 DB Delete Executing] Chuẩn bị xóa xe: ${update.params[0]}`);
                }
                await connection.execute(update.query, update.params);
                if(update.vehicleIdToRemove){
                    // DEBUG 22: Log khi xóa khỏi bộ nhớ sau DB success
                    console.log(`[DEBUG 22 Memory Remove] Đã xóa xe ${update.vehicleIdToRemove} khỏi activeVehicles.`);
                    activeVehicles = activeVehicles.filter(v => v.body_id !== update.vehicleIdToRemove);
                }
            }
            await connection.commit();
             // DEBUG 22: Log khi transaction thành công
             if (dbUpdates.some(upd => upd.query.startsWith('DELETE'))) {
                 console.log("[DEBUG 22 DB Transaction Success] Transaction bao gồm lệnh DELETE đã commit thành công.");
             }
        } catch (error) {
            console.error("❌ Lỗi DB Transaction:", error);
            await logEvent('error', `Lỗi DB Transaction: ${error.message}`);
             // DEBUG 22: Log khi transaction thất bại
             if (dbUpdates.some(upd => upd.query.startsWith('DELETE'))) {
                 console.error("[DEBUG 22 DB Transaction FAILED] Transaction bao gồm lệnh DELETE đã bị rollback!");
             }
            if (connection) { try { await connection.rollback(); } catch (rbError) { console.error("Rollback failed:", rbError); } }
        } finally {
            if (connection) { try { connection.release(); } catch (rlError) { console.error("Release failed:", rlError); } }
        }
    }

    // Broadcast nếu có thay đổi và đặt lịch cho tick tiếp theo
    if (stateChanged) { updateAndBroadcastState(); }
    if (simulationIntervalId) { simulationIntervalId = setTimeout(simulationTick, SIMULATION_TICK_RATE); }
}

// --- KHỞI TẠO SERVICE ---
async function initialize(socketIoInstance, dbPool) {
    io = socketIoInstance; pool = dbPool;
    try {
        const [stationRows] = await pool.execute('SELECT * FROM stations ORDER BY id ASC'); stationsData = {}; stationRows.forEach(station => { stationsData[station.id] = { ...station, vehicles: [] }; });
        try { const [errorTypeRows] = await pool.execute('SELECT id, name FROM error_types'); errorTypesData = errorTypeRows; console.log(`✅ Service: Đã tải ${errorTypesData.length} loại lỗi.`); } catch (error) { console.error("❌ Lỗi tải error_types:", error); errorTypesData = []; }
        const [vehicleRows] = await pool.execute(SELECT_VEHICLES_QUERY + " ORDER BY v.current_station_id ASC, v.created_at ASC"); activeVehicles = vehicleRows.map(v => ({ ...v, slotEntryTime: Date.now(), stationEntryTime: Date.now() }));
        console.log('✅ Service: Đã tải dữ liệu thành công.'); await logEvent('info', 'Hệ thống đã khởi tạo.');
        updateAndBroadcastState(); startSimulation();
    } catch (error) { console.error("❌ Lỗi khởi tạo:", error); await logEvent('error', `Lỗi khởi tạo: ${error.message}`); }
}

// --- THÊM XE MỚI VÀO BUFFER ---
async function addVehicle(body_id) {
    try {
        if (activeVehicles.some(v => v.body_id === body_id)) throw new Error(`Xe "${body_id}" đã có.`);
        const [bodyRows] = await pool.execute('SELECT * FROM car_bodies WHERE body_id = ?', [body_id]); if (bodyRows.length === 0) throw new Error(`Mã thân xe "${body_id}" không tồn tại.`);
        await pool.execute('INSERT INTO vehicles (body_id, current_station_id, slot_position, status, primer_lap_count, current_error_type_id) VALUES (?, ?, ?, ?, ?, ?)', [body_id, 0, 0, 'ok', 0, null]);
        const message = `Thêm xe mới: ${body_id} vào buffer chờ.`; await logEvent('success', message);
        const [newVehicleRows] = await pool.execute(`${SELECT_VEHICLES_QUERY} WHERE v.body_id = ?`, [body_id]);
        if (newVehicleRows.length > 0) { const newVehicleData = { ...newVehicleRows[0], slotEntryTime: Date.now(), stationEntryTime: Date.now(), current_error_name: null }; activeVehicles.push(newVehicleData); }
        updateAndBroadcastState();
    } catch (error) { console.error(`❌ Lỗi thêm xe ${body_id}: ${error.message}`); await logEvent('error', `Lỗi thêm xe ${body_id}: ${error.message}`); throw error; }
}

// --- ĐIỀU KHIỂN MÔ PHỎNG ---
function startSimulation() { if (simulationIntervalId) return; console.log(`▶️ Mô phỏng bắt đầu (tick ${SIMULATION_TICK_RATE}ms).`); logEvent('info', `Mô phỏng bắt đầu (tick ${SIMULATION_TICK_RATE}ms).`); simulationIntervalId = setTimeout(simulationTick, SIMULATION_TICK_RATE); }
function stopSimulation() { if (simulationIntervalId) { clearTimeout(simulationIntervalId); simulationIntervalId = null; console.log('⏹️ Mô phỏng đã dừng.'); logEvent('info', 'Mô phỏng đã dừng.'); } }

// --- DỪNG KHẨN CẤP VÀ XÓA XE ---
async function emergencyStopAndClear() {
    stopSimulation();
    const message = 'Dừng khẩn cấp: Dây chuyền dừng, xe đã xóa.'; console.log(`🔥 ${message}`); await logEvent('error', message);
    let connection;
    try {
        connection = await pool.getConnection(); await connection.beginTransaction();
        await connection.execute('SET FOREIGN_KEY_CHECKS = 0;'); await connection.execute('TRUNCATE TABLE vehicles'); await connection.execute('SET FOREIGN_KEY_CHECKS = 1;');
        await connection.commit();
        activeVehicles = []; updateAndBroadcastState(); console.log('✅ Đã xóa xe thành công.');
    } catch (error) { console.error("❌ Lỗi dừng khẩn cấp:", error); await logEvent('error', `Lỗi dừng khẩn cấp: ${error.message}`); if(connection) await connection.rollback(); }
    finally { if(connection) connection.release(); }
}

// --- XÓA XE THỦ CÔNG ---
async function removeVehicle(body_id) {
    console.log(`[RemoveVehicle] Yêu cầu xóa xe: ${body_id}`);
    const vehicleIndex = activeVehicles.findIndex(v => v.body_id === body_id);
    if (vehicleIndex === -1) throw new Error(`Xe "${body_id}" không tìm thấy.`);
    const vehicleToRemove = activeVehicles[vehicleIndex]; const stationId = vehicleToRemove.current_station_id;
    const wasRunning = !!simulationIntervalId; if(wasRunning) stopSimulation();
    let connection;
    try {
        connection = await pool.getConnection(); await connection.beginTransaction();
        await connection.execute('DELETE FROM vehicles WHERE body_id = ?', [body_id]);
        activeVehicles.splice(vehicleIndex, 1);
        stateChanged = true;
        if (stationId !== 0) {
            const remainingVehicles = activeVehicles.filter(v => v.current_station_id === stationId).sort((a, b) => a.slot_position - b.slot_position);
            const shiftUpdates = []; let needsDbShiftUpdate = false;
            remainingVehicles.forEach((v, newIndex) => { if (v.slot_position !== newIndex) { shiftUpdates.push(connection.execute('UPDATE vehicles SET slot_position = ? WHERE body_id = ?', [newIndex, v.body_id])); v.slot_position = newIndex; needsDbShiftUpdate = true; } });
            if (needsDbShiftUpdate) { await Promise.all(shiftUpdates); }
        }
        await connection.commit(); console.log(`[RemoveVehicle] Xóa và dịch chuyển xe ${body_id} thành công.`);
        await logEvent('warning', `Xe ${body_id} đã bị xóa khỏi trạm/buffer.`); updateAndBroadcastState();
    } catch (error) { console.error(`❌ REMOVE_VEHICLE_ERROR (${body_id}): ${error.message}`); await logEvent('error', `Lỗi khi xóa xe ${body_id}: ${error.message}`); if(connection) await connection.rollback(); throw error; }
    finally { if(connection) connection.release(); if(wasRunning) startSimulation(); }
}

// --- BÁO LỖI MÁY MÓC ---
function reportOperationalError(stationId) {
    const station = stationsData[stationId];
    if (station) {
        const message = `Sự cố máy móc: ${station.name}.`; console.log(`🚨 ${message}`); logEvent('error', message); io.emit('operational-error', { stationName: station.name, message: message });
        stopSimulation();
        activeVehicles.filter(v => v.current_station_id === stationId).forEach(v => { v.status = 'error_stoppage'; }); updateAndBroadcastState();
    }
}

// --- LOGIC ĐỊNH TUYẾN XE ---
function getNextStationId(vehicle) {
    // Không di chuyển nếu đang dừng do lỗi máy móc/logic
    if (['error_stoppage', 'error_logic'].includes(vehicle.status)) { return vehicle.current_station_id; }
    if (vehicle.current_station_id === 0) { return 0; } // Xe buffer không tự đi

    const currentStationId = vehicle.current_station_id;

    // --- Luồng sửa chữa ---
    if (currentStationId === repair_station_id) { return post_repair_destination_id; } // 23 -> 12
    if (currentStationId === inspection_station_id && vehicle.status === 'rework') { return repair_station_id; } // 10 (Lỗi) -> 23
    if (currentStationId === TOPCOAT_INSPECTION_ID && vehicle.status === 'rework') { return OFFLINE_REPAIR_ID; } // 17 (Lỗi) -> 25
    if (currentStationId === OFFLINE_REPAIR_ID) { // Rời trạm 25
        if (vehicle.status === 'ok') { return FINISHING_ID; } // Sửa OK -> 18
        if (vehicle.status === 'rework_offline') { return WAIT_RECOAT_ID; } // Sửa hỏng -> 24
        return currentStationId; // An toàn: Giữ lại nếu status lạ
    }
    if (currentStationId === WAIT_RECOAT_ID) { return post_repair_destination_id; } // 24 -> 12
    // --- Kết thúc luồng sửa chữa ---

    // Luồng sơn lót
    if (currentStationId === 14) {
        const destination = vehicle.primer_lap_count < 1 ? 9 : 15;
        return destination;
    }

    // --- Luồng chính ---
    const mainFlowPath = {
        1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10,
        10: 11, // 10 (OK) -> 11
        11: 12, 12: 13, 13: 14, /* 14 */ 15: 17,
        17: 18, // 17 (OK) -> 18
        18: 19, 19: 20, 20: 22, 22: null // Kết thúc
    };
    return mainFlowPath[currentStationId] !== undefined ? mainFlowPath[currentStationId] : null;
}


// --- LẤY TRẠNG THÁI HIỆN TẠI ĐỂ GỬI CHO CLIENT ---
function getState() {
    // Chỉ gửi các trường cần thiết cho client
    const cleanVehicles = activeVehicles.map(v => {
        // Bỏ qua các trường chỉ dùng ở backend
        const { slotEntryTime, stationEntryTime, timerId, ...vehicleData } = v;
        return vehicleData;
    });
    return {
        stations: Object.values(stationsData), // Chuyển object thành mảng
        vehicles: cleanVehicles
    };
}

// --- GỬI TRẠNG THÁI MỚI CHO TẤT CẢ CLIENT ---
function updateAndBroadcastState() {
    const currentState = getState();
    // Gán danh sách xe vào từng trạm để client dễ xử lý
    currentState.stations.forEach(station => {
        station.vehicles = currentState.vehicles
            .filter(v => v.current_station_id === station.id)
            .sort((a, b) => a.slot_position - b.slot_position); // Sắp xếp theo slot
     });
    io.emit('state-update', currentState); // Gửi qua socket
}

// --- EXPORT CÁC HÀM CÔNG KHAI ---
module.exports = {
    initialize,
    start: startSimulation,
    stop: stopSimulation,
    addVehicle,
    getState,
    reportOperationalError,
    emergencyStopAndClear,
    removeVehicle,
};